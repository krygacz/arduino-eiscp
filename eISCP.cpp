#include "Arduino.h"
#include "eISCP.h"

void eISCP_Message::decode(char* cmsg) {
	// Strip terminating characters
	String* msg = new String(strtok(cmsg, "\x1A\0\r\n"));
	// Check if we have a valid eISCP message
	if(msg->substring(0, 2) != "!1"){
		status = eISCP_MESSAGE_INVALID;
		return;
	}
	content = msg->substring(2);
	delete msg;
}

String eISCP_Message::encode() {
	// Add prefix and a terminating character
	return "!1" + content + '\r';
}

eISCP_Message::eISCP_Message(String _content, bool _autogenerated){
	status = eISCP_MESSAGE_INITIALIZED;
	content = _content;
	autogenerated = _autogenerated;
}


eISCP::eISCP(const char _ip_address[], int _port, Client* _client, bool _batch_processing) {
	ip_address = _ip_address;
	port = _port;
	client = _client;
	batch_processing = _batch_processing;
	if(batch_processing){
		send_buffer = new eISCP_Message* [eISCP_MESSAGE_BUFFER_SIZE];
		send_buffer_index = 0;
	}
	client->connect(ip_address, port);
}


void eISCP::set_callback(void (*_callback)(eISCP_Message*)) {
	callback = _callback;
}


bool eISCP::connected() {
	if(!client->connected() && !client->available())
		if (!client->connect(ip_address, port))
			return false;
	return true;
}


void eISCP::handle() {
	if(!connected()) return;
	// Read all incoming messages
	while(client->available() >= 16){
		yield();
		get_packet();
	}
	// Send queued messages if batch processing is enabled
	if(batch_processing){
		for(unsigned int i = 0; i < send_buffer_index; i++){
			yield();
			send_packet(send_buffer[i]);
		}
		send_buffer_index = 0;
	}
}


void eISCP::enqueue(eISCP_Message* message){
	message->status = eISCP_MESSAGE_PENDING;
	if(batch_processing){
		// If buffer is full we need to process it first
		if(send_buffer_index >= eISCP_MESSAGE_BUFFER_SIZE) handle();
		send_buffer[send_buffer_index++] = message;
	} else {
		
		send_packet(message);
	}
}


void eISCP::send(String command) {
	eISCP_Message* message = new eISCP_Message(command, true);
	enqueue(message);
}


void eISCP::send(eISCP_Message* message) {
	enqueue(message);
}


void eISCP::send_packet(eISCP_Message* message) {
	if(!connected()){
		message->status = eISCP_MESSAGE_NOT_SENT;
		return;
	}
	eISCP_Header* header = new eISCP_Header;
	header->size_body = __builtin_bswap32(message->encode().length());
	const byte* p = (const byte*) header;
	for (unsigned int i = 0; i < sizeof *header; i++)
		client->write(*p++);
	client->print(message->encode());
	message->status = eISCP_MESSAGE_SENT;
	delete header;
	if(message->autogenerated)
		delete message;
}


void eISCP::get_packet() {
	if(!connected()) return;
	eISCP_Header* header = new eISCP_Header;
	if(client->readBytes((byte*) header, 16) == 16){
		// Swap endianness
		header->size_header = __builtin_bswap32(header->size_header);
		header->size_body = __builtin_bswap32(header->size_body);
		// Check if header is valid
		if(strncmp(header->magic, "ISCP", 4) != 0 || header->size_header != 16){
			delete header;
			return;
		}
	} else {
		delete header;
		return;
	}
	char* buffer = new char[header->size_body];
	unsigned long timeout = millis(), index = 0;

	// Read message to buffer byte by byte
	while(index < header->size_body){
		yield();
		if (millis() - timeout > eISCP_REQUEST_TIMEOUT)
			break;
		byte b = client->read();
		if(b) buffer[index++] = b;
	}
	
	eISCP_Message* message = new eISCP_Message();
	message->status = eISCP_MESSAGE_RECEIVED;
	message->decode(buffer);
	delete[] buffer;

	// Check if the whole message was read
	if(index != header->size_body)
		message->status = eISCP_MESSAGE_INVALID;
	delete header;

	// Call the callback function if present
	if(callback != nullptr) 
		callback(message);
}