#ifndef eISCP_h
#define eISCP_h

#include "Arduino.h"
#include "Client.h"

#define eISCP_MESSAGE_INITIALIZED 0
#define eISCP_MESSAGE_PENDING 1
#define eISCP_MESSAGE_SENT 2
#define eISCP_MESSAGE_RECEIVED 3
#define eISCP_MESSAGE_INVALID -1
#define eISCP_MESSAGE_NOT_SENT -2

#define eISCP_REQUEST_TIMEOUT 500

#define eISCP_MESSAGE_BUFFER_SIZE 50

// Header structure based on https://github.com/miracle2k/onkyo-eiscp/blob/master/eiscp/core.py
typedef struct __attribute__ ((packed)) {
  char magic[4] = {'I', 'S', 'C', 'P'};
  uint32_t size_header = __builtin_bswap32(16);
  uint32_t size_body = __builtin_bswap32(0);
  signed char version = 0x01;
  char reserved[3] = {'\x00','\x00','\x00'};
} eISCP_Header;

class eISCP_Message {
  public:
    eISCP_Message(String _content = "", bool _autogenerated = false);
    String encode();
    void decode(char* cmsg);
    String content;
    int status;
    bool autogenerated;
};

class eISCP {
  public:
    eISCP(const char ip_address[], int port, Client* client, bool _batch_processing = false);
    void send(String command);
    void send(eISCP_Message* message);
    bool connected();
    void set_callback(void (*_callback)(eISCP_Message*));
    void handle();

  private:
    void get_packet();
    void send_packet(eISCP_Message* message);
    void enqueue(eISCP_Message* message);
    void (*callback)(eISCP_Message*);
    eISCP_Message** send_buffer;
    Client* client;
    unsigned int send_buffer_index;
    bool batch_processing;
    const char* ip_address;
    int port;
};

#endif